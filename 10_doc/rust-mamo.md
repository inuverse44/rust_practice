# Rustに関するメモ

- AOTコンパイル言語である。
    - AOT: ahead-of-time（予め）
    - コンパイルにして実行可能にしておけば、誰でも実行可能(rustがなくてもOK)
- rustcは小規模、Cargo（ビルド＆パッケージマネジャ）は大規模
- 以降はCargoが前提
- Cargo.lock
    - 依存関係の正確なバージョンを記録する
    - 手動変更必要なし
- 基本は`cargo run`が楽
- `cargo check`
    - コンパイルできるかを素早くチェック
    - buildより高速。実行ファイルを生成しないので
    - *Rustacean*は定期的に実行している
- `cargo build --release`
    - リリースに向けた最適化
    - コンパイルが長くなる
- クレート
    - Rustソースコードを集めたもの
    - randはライブラリクレート
    - 単独実行は不可
- Rng トレイト
    - トレイトとはなんだよ？
- クレートとトレイト
- `Ordering`も`enum`の一つ
    - enumerate
    - 列挙
- shadowする（覆い隠す）
    - 同じ変数を再利用することができる
    - なぜshadowが必要だっただろうか？
- 特殊な表現
    - 新しい変数を`guess.trim().parse()`という式に束縛する

## 3 一般的なプログラミングの概念
- 変数は標準で不変になる(invariantではなくimutable)
- Rustでは、値が不変であると宣言したら、本当に変わらないことをコンパイラが担保する
- コードを読み書きするときに、どのように値が変化するか追跡する必要がなくなる
- 大きなデータ構造
    - インスタンスをコピーしてメモリを割り当てたインスタンスよりも、可変にしておいて変更する方が早い
- 小さなデータ構造
    - インスタンスをコピーして新規インスタンスを生成した方が考えやすくなる
- 定数
    - mutキーワードは使えない
    - 必ず型注釈（型アノテーション）が必要
    - 光速度とか！ `const SPEED_OF_LIGHT: u64 = 299_792_458;`
- 整数型はi32が無難
- 不動少数点型
    - f32, f64なら基準はf64
    - 精度が高い
    - 研究室時代、Cで`double`を使えってよく言われるやつ
- タプル
    - 複数の方を何らかの値を1つの複合型にまとめ上げる
- 配列
    - 配列も複数のコレクション
    - 配列の全要素は同じ型
    - ヒープよりもスタックにデータのメモリを確保したいときに有効
    - 固定長の要素があることを確認したいときに有効
    - 配列とベクタ型、どっちかわからないときはベクタ型が吉
- 文 (statement)
    - 文は値を返さない
    - Cだと`x = y = 6`という書き方ができるが、Rustではできない
- 式
    - 式は文末にセミコロンを含まない
- if式
    - 波括弧の中身を*arm*ということがある
    - pythonと違い、`if number`はできない。
    - ifで評価される対象はbool型出ないけれなならない
    - Rustは論理値以外が自動的に論理値に変換されない。
    - 明示的に論理式を与えなければならない
    - armの型は等しくないといけない
- loop
- 配列で終端を超えてアクセスすることを許容しない
    - Cではこれは開発者が個々人で気を付けるしかない
    - Rustaceanは`for` loopを使う。
- というかなんで`println!`のようにエクスクラメーションマークがついているの？


## 4 所有権を理解する
- メモリ管理
    - 1. 手動管理。自分でメモリを確保、開放する
    - 2. 定期的に使用されていないメモリを検索するガベージコレクション
    - 3. 所有権（Rust）
- スタック/ヒープ
    - スタック
        - last in, first out
        - データ追加を"スタックにpushする"
        - データ除去を"スタックからpopする"
        - スタックは高速
        - 高速のために、データは既知の固定サイズ
    - ヒープ
        - ごちゃごちゃ
        - 空の領域を使用中にし、ポインタを返す
        - ポインタはアドレス
        - ヒープに領域を確保するという (allocating on the heap)
        - malloc
        - ポインタは固定サイズだが、データを取り出すなら、ポインタを追跡しないといけない
        - スタックよりも低速
            - ポインタで追跡するため、あちこち移動するのがコスト
- 所有権規則
    - Rustの各値は、**所有者**と呼ばれる変数と対応している
    - いかなる時も所有者は1つ
    - 所有者がスコープから外れたら、値は破棄される
- String型は可変化できるが、リテラルはできない
- 文字列リテラルはコンパイル時に長さが決まっているから、バイナリに直接ハードコードされる
- 現実的に文字列はコンパイル時に長さがわからない
- メモリは実行時にOSに要求される
- String型が使用し終わったら、OSにこのメモリを変換する方法が必要である
- **メモリを所有している変数がスコープを抜けたら、メモリは自動的に変換される**
    - 明示的に`malloc`や`free`をする必要はない
        - `malloc`と`free`は１対１の関係
    - GCがある場合にはこいつが勝手に検知する
    - メモリ開放を
        - 言語の仕様で克服したのがRust
        - 機能で克服しようとしたのがJava系言語
- 変数がスコープを抜ける時、Rustは特別な間数`drop`を呼ぶ
- String型
    - ポインタ
    - 長さ
    - 許容量
- 自動的なデータの"deep copy"はRustでは絶対に起きない
- `clone`メソッドの呼び出しは、実行コストが高い
- Rustはデータ競合が起こるコードをコンパイルさえしない
- スライス意味がわからない


## 5 構造体
- パッケージ
    - クレートをビルドし、テストし、共有することができるCargoの機能
- クレート
    - ライブラリが実行可能ファイルを生成する、木構造をしたモジュール群
- モジュールとuse
    - パスの構成、スコープ、公開するか否かを決定可能
- パス
    - 要素（e.g., 構造体や関数、モジュール）に名前をつける方法

- パッケージはクレートを1つ以上持つ
- クレートは、関連した機能を1つのスコープにまとめる
    - `rand`クレートが提供する機能にはすべて、クレートの名前`rand`でアクセスできる
- クレートはトレイトを提供する

---

## パッケージ・クレート・モジュール・トレイトの関係性

これらはコードを整理・管理するための仕組みで、大きな箱から小さな箱へと階層構造になっています。

### 階層構造のまとめ

1.  **パッケージ (Package)**: 一番大きな箱
    *   Cargoの機能で、1つ以上の**クレート**を含むプロジェクト全体です。
    *   `Cargo.toml`ファイルで定義され、ビルド、テスト、共有の単位となります。
    *   例えるなら「アプリケーション全体」や「ライブラリプロジェクト全体」です。

2.  **クレート (Crate)**: パッケージの中の部品
    *   ライブラリまたは実行可能ファイルを生成する、**モジュール**の集合体です。コンパイルの単位でもあります。
    *   1つのパッケージには、ライブラリクレートが最大1つと、複数のバイナリ（実行可能）クレートを含めることができます。
    *   `src/main.rs`はバイナリクレートのルート、`src/lib.rs`はライブラリクレートのルートになります。

3.  **モジュール (Module)**: クレートの中の整理棚
    *   クレート内のコードを整理し、名前空間を分けるための仕組みです。
    *   `mod`キーワードで定義し、アイテム（関数、構造体、**トレイト**など）の公開/非公開を制御できます。

---

### トレイト (Trait) との関係

*   **トレイト (Trait)** は、上記の階層構造とは少し性質が異なります。これは「**どのような振る舞いができるか**」を定義するものです（他の言語のインターフェースに似ています）。
*   トレイトは、**モジュールの中に定義されるアイテムの一種**です。
*   クレートは、便利な機能（関数や構造体）と共に、それらの型が実装すべき**トレイト**を提供することができます。メモにある通り、`rand`クレートが`Rng`トレイトを提供しているのが良い例です。

### 関係を図にすると

```
パッケージ (プロジェクト全体)
├── Cargo.toml (パッケージの設定ファイル)
│
└── クレートA (例: ライブラリ)
    ├── モジュール X
    │   ├── 関数
    │   ├── 構造体
    │   └── トレイト (振る舞いの定義)
    │
    └── モジュール Y
        └── ...

└── クレートB (例: 実行可能ファイル)
    └── ... (クレートAを利用する)
```

**まとめ**: 「**パッケージ**というプロジェクトの中に、**クレート**というコンパイル単位の部品があり、その部品の中は**モジュール**で整理されている。そして、それらのモジュールの中に、具体的な機能を持つ関数や構造体、そして振る舞いを定義する**トレイト**などが配置されている」という関係になります。