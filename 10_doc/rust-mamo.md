# Rustに関するメモ

- AOTコンパイル言語である。
    - AOT: ahead-of-time（予め）
    - コンパイルにして実行可能にしておけば、誰でも実行可能(rustがなくてもOK)
- rustcは小規模、Cargo（ビルド＆パッケージマネジャ）は大規模
- 以降はCargoが前提
- Cargo.lock
    - 依存関係の正確なバージョンを記録する
    - 手動変更必要なし
- 基本は`cargo run`が楽
- `cargo check`
    - コンパイルできるかを素早くチェック
    - buildより高速。実行ファイルを生成しないので
    - *Rustacean*は定期的に実行している
- `cargo build --release`
    - リリースに向けた最適化
    - コンパイルが長くなる
- クレート
    - Rustソースコードを集めたもの
    - randはライブラリクレート
    - 単独実行は不可
- Rng トレイト
    - トレイトとはなんだよ？
- クレートとトレイト
- `Ordering`も`enum`の一つ
    - enumerate
    - 列挙
- shadowする（覆い隠す）
    - 同じ変数を再利用することができる
    - なぜshadowが必要だっただろうか？
- 特殊な表現
    - 新しい変数を`guess.trim().parse()`という式に束縛する

## 3 一般的なプログラミングの概念
- 変数は標準で不変になる(invariantではなくimutable)
- Rustでは、値が不変であると宣言したら、本当に変わらないことをコンパイラが担保する
- コードを読み書きするときに、どのように値が変化するか追跡する必要がなくなる
- 大きなデータ構造
    - インスタンスをコピーしてメモリを割り当てたインスタンスよりも、可変にしておいて変更する方が早い
- 小さなデータ構造
    - インスタンスをコピーして新規インスタンスを生成した方が考えやすくなる
- 定数
    - mutキーワードは使えない
    - 必ず型注釈（型アノテーション）が必要
    - 光速度とか！ `const SPEED_OF_LIGHT: u64 = 299_792_458;`
- 整数型はi32が無難
- 不動少数点型
    - f32, f64なら基準はf64
    - 精度が高い
    - 研究室時代、Cで`double`を使えってよく言われるやつ
- タプル
    - 複数の方を何らかの値を1つの複合型にまとめ上げる
- 配列
    - 配列も複数のコレクション
    - 配列の全要素は同じ型
    - ヒープよりもスタックにデータのメモリを確保したいときに有効
    - 固定長の要素があることを確認したいときに有効
    - 配列とベクタ型、どっちかわからないときはベクタ型が吉
- 文 (statement)
    - 文は値を返さない
    - Cだと`x = y = 6`という書き方ができるが、Rustではできない
- 式
    - 式は文末にセミコロンを含まない
- if式
    - 波括弧の中身を*arm*ということがある
    - pythonと違い、`if number`はできない。
    - ifで評価される対象はbool型出ないけれなならない
    - Rustは論理値以外が自動的に論理値に変換されない。
    - 明示的に論理式を与えなければならない
    - armの型は等しくないといけない
- loop
- 配列で終端を超えてアクセスすることを許容しない
    - Cではこれは開発者が個々人で気を付けるしかない
    - Rustaceanは`for` loopを使う。
- というかなんで`println!`のようにエクスクラメーションマークがついているの？


## 4 所有権を理解する
- メモリ管理
    - 1. 手動管理。自分でメモリを確保、開放する
    - 2. 定期的に使用されていないメモリを検索するガベージコレクション
    - 3. 所有権（Rust）
- スタック/ヒープ
    - スタック
        - last in, first out
        - データ追加を"スタックにpushする"
        - データ除去を"スタックからpopする"
        - スタックは高速
        - 高速のために、データは既知の固定サイズ
    - ヒープ
        - ごちゃごちゃ
        - 空の領域を使用中にし、ポインタを返す
        - ポインタはアドレス
        - ヒープに領域を確保するという (allocating on the heap)
        - malloc
        - ポインタは固定サイズだが、データを取り出すなら、ポインタを追跡しないといけない
        - スタックよりも低速
            - ポインタで追跡するため、あちこち移動するのがコスト
- 所有権規則
    - Rustの各値は、**所有者**と呼ばれる変数と対応している
    - いかなる時も所有者は1つ
    - 所有者がスコープから外れたら、値は破棄される
- String型は可変化できるが、リテラルはできない
- 文字列リテラルはコンパイル時に長さが決まっているから、バイナリに直接ハードコードされる
- 現実的に文字列はコンパイル時に長さがわからない
- メモリは実行時にOSに要求される
- String型が使用し終わったら、OSにこのメモリを変換する方法が必要である
- **メモリを所有している変数がスコープを抜けたら、メモリは自動的に変換される**
    - 明示的に`malloc`や`free`をする必要はない
        - `malloc`と`free`は１対１の関係
    - GCがある場合にはこいつが勝手に検知する
    - メモリ開放を
        - 言語の仕様で克服したのがRust
        - 機能で克服しようとしたのがJava系言語
- 変数がスコープを抜ける時、Rustは特別な間数`drop`を呼ぶ
- String型
    - ポインタ
    - 長さ
    - 許容量
- 自動的なデータの"deep copy"はRustでは絶対に起きない
- `clone`メソッドの呼び出しは、実行コストが高い
- Rustはデータ競合が起こるコードをコンパイルさえしない
- スライス意味がわからない


## 5 構造体